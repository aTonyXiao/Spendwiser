<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/local/storage.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>

    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="nav">
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="Account.html">Account</a></li></ul><h3>Modules</h3><ul><li><a href="module-AddCardDB.html">AddCardDB</a></li><li><a href="module-AddCardManual.html">AddCardManual</a></li><li><a href="module-AddCardModal.html">AddCardModal</a></li><li><a href="module-App.html">App</a></li><li><a href="module-BackButtonHeader.html">BackButtonHeader</a></li><li><a href="module-CameraSettingsBar.html">CameraSettingsBar</a></li><li><a href="module-Card.html">Card</a></li><li><a href="module-CardImage.html">CardImage</a></li><li><a href="module-CardSelect.html">CardSelect</a></li><li><a href="module-ChooseImage.html">ChooseImage</a></li><li><a href="module-DisplayCard.html">DisplayCard</a></li><li><a href="module-DoubleTap.html">DoubleTap</a></li><li><a href="module-EditImage.html">EditImage</a></li><li><a href="module-EditTransactionModal.html">EditTransactionModal</a></li><li><a href="module-Footer.html">Footer</a></li><li><a href="module-HelpModal.html">HelpModal</a></li><li><a href="module-LoadingScreen.html">LoadingScreen</a></li><li><a href="module-MainScreen.html">MainScreen</a><ul class='methods'><li data-type='method'><a href="module-MainScreen.html#~addManualInput">addManualInput</a></li><li data-type='method'><a href="module-MainScreen.html#~backAction">backAction</a></li><li data-type='method'><a href="module-MainScreen.html#~getDisabledCards">getDisabledCards</a></li><li data-type='method'><a href="module-MainScreen.html#~getLocationFromAPI">getLocationFromAPI</a></li><li data-type='method'><a href="module-MainScreen.html#~getRecCardFromDB">getRecCardFromDB</a></li><li data-type='method'><a href="module-MainScreen.html#~onBottomSheetLayout">onBottomSheetLayout</a></li><li data-type='method'><a href="module-MainScreen.html#~reloadRecCard">reloadRecCard</a></li><li data-type='method'><a href="module-MainScreen.html#~setLocationDisabledMode">setLocationDisabledMode</a></li><li data-type='method'><a href="module-MainScreen.html#~setOfflineMode">setOfflineMode</a></li><li data-type='method'><a href="module-MainScreen.html#~switchStoresFromPOI">switchStoresFromPOI</a></li><li data-type='method'><a href="module-MainScreen.html#~tryToGetStoresFromLocation">tryToGetStoresFromLocation</a></li></ul></li><li><a href="module-MoveableBlock.html">MoveableBlock</a></li><li><a href="module-SpendingSummary.html">SpendingSummary</a><ul class='methods'><li data-type='method'><a href="module-SpendingSummary.html#~changeCategoriesLimit">changeCategoriesLimit</a></li><li data-type='method'><a href="module-SpendingSummary.html#~changeCategory">changeCategory</a></li><li data-type='method'><a href="module-SpendingSummary.html#~getCardFromDB">getCardFromDB</a></li><li data-type='method'><a href="module-SpendingSummary.html#~getCompareTimeFrameTransactions">getCompareTimeFrameTransactions</a></li><li data-type='method'><a href="module-SpendingSummary.html#~processTransaction">processTransaction</a></li><li data-type='method'><a href="module-SpendingSummary.html#~setCurCardFromModal">setCurCardFromModal</a></li><li data-type='method'><a href="module-SpendingSummary.html#~setNewPeriod">setNewPeriod</a></li></ul></li><li><a href="module-Textbox.html">Textbox</a></li><li><a href="module-YourCards.html">YourCards</a></li></ul><h3>Classes</h3><ul><li><a href="AppleLogin.html">AppleLogin</a></li><li><a href="BaseBackend.html">BaseBackend</a><ul class='methods'><li data-type='method'><a href="BaseBackend.html#dbAdd">dbAdd</a></li><li data-type='method'><a href="BaseBackend.html#dbAddEncrypted">dbAddEncrypted</a></li><li data-type='method'><a href="BaseBackend.html#dbDelete">dbDelete</a></li><li data-type='method'><a href="BaseBackend.html#dbDoesDocExist">dbDoesDocExist</a></li><li data-type='method'><a href="BaseBackend.html#dbGet">dbGet</a></li><li data-type='method'><a href="BaseBackend.html#dbGetEncrypted">dbGetEncrypted</a></li><li data-type='method'><a href="BaseBackend.html#dbGetSubCollections">dbGetSubCollections</a></li><li data-type='method'><a href="BaseBackend.html#dbSet">dbSet</a></li><li data-type='method'><a href="BaseBackend.html#dbSetEncrypted">dbSetEncrypted</a></li><li data-type='method'><a href="BaseBackend.html#doesSupportDatabase">doesSupportDatabase</a></li><li data-type='method'><a href="BaseBackend.html#enableDatabaseCaching">enableDatabaseCaching</a></li><li data-type='method'><a href="BaseBackend.html#getLoginProviders">getLoginProviders</a></li><li data-type='method'><a href="BaseBackend.html#getTimestamp">getTimestamp</a></li><li data-type='method'><a href="BaseBackend.html#getUserID">getUserID</a></li><li data-type='method'><a href="BaseBackend.html#getUserInfo">getUserInfo</a></li><li data-type='method'><a href="BaseBackend.html#initializeApp">initializeApp</a></li><li data-type='method'><a href="BaseBackend.html#onAuthStateChange">onAuthStateChange</a></li><li data-type='method'><a href="BaseBackend.html#resetPassword">resetPassword</a></li><li data-type='method'><a href="BaseBackend.html#setPrivateKey">setPrivateKey</a></li><li data-type='method'><a href="BaseBackend.html#signIn">signIn</a></li><li data-type='method'><a href="BaseBackend.html#signInOffline">signInOffline</a></li><li data-type='method'><a href="BaseBackend.html#signOut">signOut</a></li><li data-type='method'><a href="BaseBackend.html#signUp">signUp</a></li><li data-type='method'><a href="BaseBackend.html#userAccountType">userAccountType</a></li><li data-type='method'><a href="BaseBackend.html#userLoggedIn">userLoggedIn</a></li></ul></li><li><a href="Cards.html">Cards</a><ul class='methods'><li data-type='method'><a href="Cards.html#addCardToDatabase">addCardToDatabase</a></li><li data-type='method'><a href="Cards.html#addJsonToDatabase">addJsonToDatabase</a></li><li data-type='method'><a href="Cards.html#getCardData">getCardData</a></li><li data-type='method'><a href="Cards.html#getCardImageURL">getCardImageURL</a></li><li data-type='method'><a href="Cards.html#getCardImg">getCardImg</a></li><li data-type='method'><a href="Cards.html#getCardName">getCardName</a></li><li data-type='method'><a href="Cards.html#getCardNames">getCardNames</a></li><li data-type='method'><a href="Cards.html#getCardReward">getCardReward</a></li></ul></li><li><a href="FacebookLogin.html">FacebookLogin</a></li><li><a href="FirebaseBackend.html">FirebaseBackend</a><ul class='methods'><li data-type='method'><a href="FirebaseBackend.html#dbAdd">dbAdd</a></li><li data-type='method'><a href="FirebaseBackend.html#dbDelete">dbDelete</a></li><li data-type='method'><a href="FirebaseBackend.html#dbDoesDocExist">dbDoesDocExist</a></li><li data-type='method'><a href="FirebaseBackend.html#dbGet">dbGet</a></li><li data-type='method'><a href="FirebaseBackend.html#dbGetSubCollections">dbGetSubCollections</a></li><li data-type='method'><a href="FirebaseBackend.html#dbGetSubCollectionsRemote">dbGetSubCollectionsRemote</a></li><li data-type='method'><a href="FirebaseBackend.html#dbSet">dbSet</a></li><li data-type='method'><a href="FirebaseBackend.html#doesSupportDatabase">doesSupportDatabase</a></li><li data-type='method'><a href="FirebaseBackend.html#enableDatabaseCaching">enableDatabaseCaching</a></li><li data-type='method'><a href="FirebaseBackend.html#getLoginProviders">getLoginProviders</a></li><li data-type='method'><a href="FirebaseBackend.html#getTimestamp">getTimestamp</a></li><li data-type='method'><a href="FirebaseBackend.html#getUserID">getUserID</a></li><li data-type='method'><a href="FirebaseBackend.html#getUserInfo">getUserInfo</a></li><li data-type='method'><a href="FirebaseBackend.html#initializeApp">initializeApp</a></li><li data-type='method'><a href="FirebaseBackend.html#onAuthStateChange">onAuthStateChange</a></li><li data-type='method'><a href="FirebaseBackend.html#remoteDBAdd">remoteDBAdd</a></li><li data-type='method'><a href="FirebaseBackend.html#remoteDBDelete">remoteDBDelete</a></li><li data-type='method'><a href="FirebaseBackend.html#remoteDBGet">remoteDBGet</a></li><li data-type='method'><a href="FirebaseBackend.html#remoteDBSet">remoteDBSet</a></li><li data-type='method'><a href="FirebaseBackend.html#resetPassword">resetPassword</a></li><li data-type='method'><a href="FirebaseBackend.html#signIn">signIn</a></li><li data-type='method'><a href="FirebaseBackend.html#signInOffline">signInOffline</a></li><li data-type='method'><a href="FirebaseBackend.html#signOut">signOut</a></li><li data-type='method'><a href="FirebaseBackend.html#signUp">signUp</a></li><li data-type='method'><a href="FirebaseBackend.html#userAccountType">userAccountType</a></li><li data-type='method'><a href="FirebaseBackend.html#userLoggedIn">userLoggedIn</a></li></ul></li><li><a href="GoogleLogin.html">GoogleLogin</a></li><li><a href="LoginAuthorizer.html">LoginAuthorizer</a><ul class='methods'><li data-type='method'><a href="LoginAuthorizer.html#login">login</a></li></ul></li><li><a href="RecommendCard.html">RecommendCard</a><ul class='methods'><li data-type='method'><a href="RecommendCard.html#getCategory">getCategory</a></li><li data-type='method'><a href="RecommendCard.html#getRecCards">getRecCards</a></li></ul></li><li><a href="ServerBackend.html">ServerBackend</a><ul class='methods'><li data-type='method'><a href="ServerBackend.html#dbAdd">dbAdd</a></li><li data-type='method'><a href="ServerBackend.html#dbDelete">dbDelete</a></li><li data-type='method'><a href="ServerBackend.html#dbDoesDocExist">dbDoesDocExist</a></li><li data-type='method'><a href="ServerBackend.html#dbGet">dbGet</a></li><li data-type='method'><a href="ServerBackend.html#dbGetSubCollections">dbGetSubCollections</a></li><li data-type='method'><a href="ServerBackend.html#dbGetSubCollectionsRemote">dbGetSubCollectionsRemote</a></li><li data-type='method'><a href="ServerBackend.html#dbSet">dbSet</a></li><li data-type='method'><a href="ServerBackend.html#doesSupportDatabase">doesSupportDatabase</a></li><li data-type='method'><a href="ServerBackend.html#enableDatabaseCaching">enableDatabaseCaching</a></li><li data-type='method'><a href="ServerBackend.html#getLoginProviders">getLoginProviders</a></li><li data-type='method'><a href="ServerBackend.html#getTimestamp">getTimestamp</a></li><li data-type='method'><a href="ServerBackend.html#getUserID">getUserID</a></li><li data-type='method'><a href="ServerBackend.html#getUserInfo">getUserInfo</a></li><li data-type='method'><a href="ServerBackend.html#getUserToken">getUserToken</a></li><li data-type='method'><a href="ServerBackend.html#initializeApp">initializeApp</a></li><li data-type='method'><a href="ServerBackend.html#onAuthStateChange">onAuthStateChange</a></li><li data-type='method'><a href="ServerBackend.html#remoteDBAdd">remoteDBAdd</a></li><li data-type='method'><a href="ServerBackend.html#remoteDBDelete">remoteDBDelete</a></li><li data-type='method'><a href="ServerBackend.html#remoteDBGet">remoteDBGet</a></li><li data-type='method'><a href="ServerBackend.html#remoteDBSet">remoteDBSet</a></li><li data-type='method'><a href="ServerBackend.html#resetPassword">resetPassword</a></li><li data-type='method'><a href="ServerBackend.html#signIn">signIn</a></li><li data-type='method'><a href="ServerBackend.html#signInOffline">signInOffline</a></li><li data-type='method'><a href="ServerBackend.html#signOut">signOut</a></li><li data-type='method'><a href="ServerBackend.html#signUp">signUp</a></li><li data-type='method'><a href="ServerBackend.html#userAccountType">userAccountType</a></li><li data-type='method'><a href="ServerBackend.html#userLoggedIn">userLoggedIn</a></li></ul></li><li><a href="SummaryHelper.html">SummaryHelper</a><ul class='methods'><li data-type='method'><a href="SummaryHelper.html#addSortedNewTransaction">addSortedNewTransaction</a></li><li data-type='method'><a href="SummaryHelper.html#getDbCards">getDbCards</a></li><li data-type='method'><a href="SummaryHelper.html#getTimeFrame">getTimeFrame</a></li><li data-type='method'><a href="SummaryHelper.html#matchTransactionToCategory">matchTransactionToCategory</a></li></ul></li><li><a href="userClass.html">userClass</a><ul class='methods'><li data-type='method'><a href="userClass.html#addTransactionId">addTransactionId</a></li><li data-type='method'><a href="userClass.html#addUser">addUser</a></li><li data-type='method'><a href="userClass.html#deleteCard">deleteCard</a></li><li data-type='method'><a href="userClass.html#deleteTransaction">deleteTransaction</a></li><li data-type='method'><a href="userClass.html#editTransaction">editTransaction</a></li><li data-type='method'><a href="userClass.html#getAllTransactions">getAllTransactions</a></li><li data-type='method'><a href="userClass.html#getCardDocId">getCardDocId</a></li><li data-type='method'><a href="userClass.html#getCards">getCards</a></li><li data-type='method'><a href="userClass.html#getMainNeedsUpdate">getMainNeedsUpdate</a></li><li data-type='method'><a href="userClass.html#getRewards">getRewards</a></li><li data-type='method'><a href="userClass.html#getTimeFrameTransactions">getTimeFrameTransactions</a></li><li data-type='method'><a href="userClass.html#getTransactionsForCard">getTransactionsForCard</a></li><li data-type='method'><a href="userClass.html#getUserId">getUserId</a></li><li data-type='method'><a href="userClass.html#saveCardToUser">saveCardToUser</a></li><li data-type='method'><a href="userClass.html#saveTransaction">saveTransaction</a></li><li data-type='method'><a href="userClass.html#setMainNeedsUpdate">setMainNeedsUpdate</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">src/local/storage.js</h1>
    

    <!--container.tmpl-->




    <!--source.tmpl-->

    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import AsyncStorage from '@react-native-async-storage/async-storage';
import sha256 from 'crypto-js/sha256';

/**
 * Store the login state of the application for future use. Anything stored here can be retrieved
 * by calling getLoginState
 * 
 * @param {Object} login_info expects two items: 'signed_in' as a boolean and 'account_type' which can either be 'normal' or 'offline'
 */
export const storeLoginState = async (login_info) => {
    try {
        const jsonValue = JSON.stringify(login_info);
        await AsyncStorage.setItem('logged in', jsonValue);
    } catch (e) {
        console.log(e);
    }
}

/**
 * 
 * @param {function} callback returns an object containing a user's 'signed_in' state and their 'account_type'. 
 * See storeLoginState function to understand the possible values for each of these items.
 */
export const getLoginState = async (callback) => {
    try {
        const jsonValue = await AsyncStorage.getItem('logged in')
        if (jsonValue == null) { // Default to not logged in
            callback({ 'signed_in': false, 'account_type': 'offline' });
        } else {
            callback(JSON.parse(jsonValue));
        }
    } catch (e) {
        console.log(e);
        return null;
    }
}

/**
 * This function is a brute force method of converting strings stored using AsyncStorage
 * back into their origin Date object. See 'convertDateToString' function for more infromation
 * on how dates are stored internally to understand the code provided.
 * 
 * @param {any} key the key in a key-value pair of a javascript object
 * @param {any} value the value associated the key in a javascript object
 */
dateTimeReviver = function (key, value) {
    if (typeof value === 'string') {
        if (value.startsWith("__date__")) {
            let lastIndex = value.length - 2;
            let datestr = value.substring("__date__(\"".length, lastIndex);
            let date = new Date(datestr);
            return date;
        } else {
            return value;
        }
    } else {
        return value;
    }
}

/**
 * Reads the database from the phone's storage and returns the data as a javascript object.
 * NOTE: This should be the only way that the database is read from AsyncStorage. Do not try to do this any other way.
 * 
 * @param {function} callback function that accepts an object containing all of the database information
 */
export const getDB = async (callback) => {
    try {
        const jsonValue = await AsyncStorage.getItem('@db');
        if (jsonValue != null) {
            var db = JSON.parse(jsonValue, dateTimeReviver);
            callback(db);
        } else {
            callback({});
        }
    } catch (e) {
        console.log(e);
    }
}

/**
 * Converts all Date objects in the database to strings with special formatting.
 * Example: 10/26/2021 is converted to "__date__(10/26/2021)". This is necessary
 * because Date objects cannot be stored natively in JSON, which is what we need to
 * convert our database to in order to write with AsyncStorage. Therefore, we
 * need a good way of determining which strings are dates when they are read back in
 * from JSON which is done here with a very recognizable format.
 * 
 * @param {Object} db the database as a javascript object
 * @returns {db} the modified db is returned
 */
const convertDateToString = (db) => {
    for (let [key, value] of Object.entries(db)) {
        if (value instanceof Date) {
            db[key] = "__date__(" + JSON.stringify(value) + ")";
        } else if (value instanceof Object) {
            db[key] = convertDateToString(value);
        }
    }

    return db;
}

/**
 * Writes the database in its entirety to local phone storage.
 * NOTE: This should be the only way that you write the database to local storage. 
 * Do not try to do it on your own.
 * 
 * @param {Object} db the javascript object containing all the database info
 * @param {function} callback called when the data has finished being stored locally
 */
const setDB = async (db, callback) => {
    db = convertDateToString(db);
    await AsyncStorage.setItem('@db', JSON.stringify(db));
    callback();
}

/**
 * Adds or updates metainfo items of an object
 * 
 * @param {Object} local_data particular sub-object contained within the database that can have metadata added to it
 * @param {boolean} isSynced whether or not the data has been synced already with a remote database
 * @returns {Object} the modified local data
 */
const addOrUpdateMetainfo = (local_data, isSynced = false) => {
    if (local_data) {
        local_data['meta_modified'] = new Date();
        local_data['meta_synced'] = isSynced;
        return local_data;
    } else {
        return null;
    }
}

/**
 * Creates a new object with metadata items removed. The metadata items removed 
 * are the ones added in the function 'addOrUpdateMetainfo' 
 * 
 * @param {Object} db_item a particular sub-object in the database
 * @returns {Object} a new object with the metadata items removed
 */
export const stripMetadata = (db_item) => {
    if (typeof db_item == 'object') {
        let stripped_data = JSON.parse(JSON.stringify(db_item));
        if ('meta_modified' in db_item) {
            delete stripped_data['meta_modified'];
        }
        if ('meta_synced' in db_item) {
            delete stripped_data['meta_synced'];
        }
        return stripped_data;
    } else {
        throw 'Data is not an object! ' + typeof db_item;
    }
}

/**
 * Adds data to a specified collection and calls the callback function when
 * all data has finished being writen to disk
 * 
 * @param {string} accountName the name of the user's account
 * @param {string} location the period delimited location of a particular document/collection
 * @param {Object} data the data that will be added to the collection
 * @param {boolean} synced whether or not the data has already been synced with a remote database
 * @param {function} callback takes one parameter that is the id of the data added to the collection in the form of a string
 */
export const addLocalDB = async (accountName, location, data, synced, callback) => {
    // Create a copy so that we don't modify the original data
    let local_data = addOrUpdateMetainfo(data);
    try {
        getDB(async (db) => {
            // Create account if not exists
            if (!(accountName in db)) {
                db[accountName] = {};
            }

            // Create location in account if not exists
            if (!(location in db[accountName])) {
                db[accountName][location] = {};
            }

            // Create a unique id for this document based on the current date
            // and the data supplied
            let id = sha256(Date().toString() + JSON.stringify(data)).toString();


            // If this document has not been synced with a remote database,
            // we need to note that in our array of unsynced documents which
            // will later be used to push this information up to the remote db
            if (synced == false) {
                addToUnsyncedDocuments(db, 'add', accountName, location, id, location);
            }

            // Copy the supplied data into our database
            local_data['meta_id'] = id;
            db[accountName][location][id.toString()] = local_data;

            // Write the database to disk
            setDB(db, () => {
                callback(id.toString());
            });
        });
    } catch (e) {
        console.log(e);
        callback(-1);
    }
}

/**
 * Determines if a document id has been modified by a sync event and returns the
 * updated id or the old id if nothing has changed
 * 
 * @param {Object} db the database in the form of a javascript object
 * @param {string} accountName the id of the user's account
 * @param {string} collection the location of the collection
 * @param {string} id the id of the data that should be accessed from the collection
 * @returns {string} the correct id of the document inside the collection
 */
const checkSyncMapping = (db, accountName, collection, id) => {
    if ('sync_mappings' in db[accountName]) {
        sync_mappings = db[accountName]['sync_mappings'];

        // Look through the array of mappings to find one that could match the passed in id
        for (let i = 0; i &lt; sync_mappings.length; i++) {
            let mapping = sync_mappings[i];
            if (mapping['location'] == collection &amp;&amp; mapping['oldId'] == id) {
                // The id has in fact been updated in our database, so we should use the new ID
                return mapping['newId'];
            }
        }

        // There has been no update to this id, we can return the id that was passed in
        return id;
    } else {
        // Sync mappings does not exist yet, we can just return the current id
        return id;
    }
}

/**
 * Deletes data locally from the database based on the location provided
 * 
 * @param {string} accountName the id of the user's account
 * @param {string} location the period delimited string denoting the collection and document id
 */
export const deleteLocalDB = async (accountName, location) => {
    try {
        getDB(async (db) => {
            let [collection, id] = parseCollectionAndDocId(location);
            let oldId = id;
            id = checkSyncMapping(db, accountName, collection, id);
            
            if (accountName in db &amp;&amp; collection in db[accountName] &amp;&amp; (id in db[accountName][collection])) {
                addToUnsyncedDocuments(db, 'delete', accountName, collection, id, location);

                // Remove any unsynced documents that relate to the location being deleted
                db[accountName]['unsynced_documents'] = 
                db[accountName]['unsynced_documents'].filter((doc, index, arr) => {
                    if (doc['location'] == collection &amp;&amp; (doc['id'] == id || doc['id'] == oldId)) {
                        if (doc['type'] == 'delete') {
                            let docIdToDelete = doc['id'];

                            let item = db[accountName][collection][docIdToDelete];
                            console.log("Item at: " + doc['location'] + "." + doc['id'])
                            console.log(item);

                            if (item['meta_synced'] == false) {
                                return false; // Since this item was not synced, we can just delete it
                            } else {
                                return true; // Item WAS synced, need to perform the action remotely as well
                            }
                        } else {
                            return false; // Remove any extraneous unsynced actions on the item being deleted
                        }
                    } else {
                        return true;
                    }
                });

                delete db[accountName][collection][id];
            }

            setDB(db, () => {
            });
        });
    } catch (e) {
        console.log(e);
    }
}

/**
 * Splits a full period delimited location string into its
 * subparts: the collection path and the document id
 * 
 * @param {string} location the period delimited location of a document
 * @returns {Array} both the collection and the document id
 */
export const parseCollectionAndDocId = (location) => {
    // Extract the unique_id from location
    let loc = location.lastIndexOf('.');
    if (loc == -1) {
        console.log("Invalid location " + location + " in setLocalDB");
        return;
    }

    let collection = location.substring(0, loc);
    let id = location.substring(loc + 1);

    return [collection, id];
}

/**
 * 
 * @param {string} accountName the user's account id
 * @param {string} location the full period delimited path containing the collection and document id
 * @param {Object} local_data the data that should be set as the value for the document id
 * @param {boolean} merge whether or not to replace
 * @param {function} callback called when the data is finished being written to disk
 */
export const setLocalDB = async (accountName, location, local_data, merge = false, callback) => {
    const [collection, id] = parseCollectionAndDocId(location);
    local_data = addOrUpdateMetainfo(local_data);
    try {
        getDB(async (db) => {
            if (accountName in db &amp;&amp; collection in db[accountName] &amp;&amp; id in db[accountName][collection]) {
                if (merge) {
                    db[accountName][collection][id] = {
                        ...db[accountName][collection][id],
                        ...local_data,
                    }
                } else {
                    db[accountName][collection][id] = local_data;
                }
                
                addToUnsyncedDocuments(db, 'set', accountName, collection, id, location);
               

                setDB(db, () => {
                    callback();
                });
            }  else {
                callback();
            }

        });
    } catch (e) {
        console.log(e);
    }
}

/**
 * deletes the entire local database
 */
export const clearLocalDB = async () => {
    await AsyncStorage.removeItem("@db");
}

/**
 * returns the database item at a particular location
 * 
 * @param {string} accountName the account id of the signed in user
 * @param {string} location the period delimited path containing the collection and document id
 * @param  {...any} conditionWithCallback any filtering parameters ending with a callback function which will be called with each individual item found
 */
export const getLocalDB = async (accountName, location, ...conditionWithCallback) => {

    const [collection, id] = parseCollectionAndDocId(location);
    try {
        getDB(async (db) => {
            let callback = conditionWithCallback.pop();
            let conditions = conditionWithCallback;

            if (!(accountName in db)) {
                db[accountName] = {};
            }

            let local_data = null;
            // Normal get operation that will return one item
            if (accountName in db &amp;&amp; collection in db[accountName] &amp;&amp; id in db[accountName][collection]) {
                local_data = db[accountName][collection][id];
            }
            // Get operation that will most likely filter the data and receive a
            // callback for each item in the array that meets certain conditions
            else if (accountName in db &amp;&amp; location in db[accountName]) {
                local_data = Object.values(db[accountName][location]);
            }
            // NOTE: Look into the db's mappings from localdb generated id's to remote generated id's that
            // have been replaced. Components can reference old id's if they are not updated after a sync
            // operation but they still want to refer to the data
            else if ('sync_mappings' in db[accountName]) {
                sync_mappings = db[accountName]['sync_mappings'];
                sync_mappings.forEach((mapping) => {
                    if (mapping['location'] == collection &amp;&amp; mapping['oldId'] == id) {
                        if (accountName in db &amp;&amp; collection in db[accountName] &amp;&amp; mapping['newId'] in db[accountName][collection]) {
                            local_data = db[accountName][collection][mapping['newId']];
                        }
                    }
                });
            }

            var comp_op = {
                '==': function (x, y) { return x == y},
                '>': function (x, y) { 
                    return x > y;
                },
                '&lt;': function (x, y) { 
                    return x &lt; y;
                },
            }

            // NOTE (Nathan W): This was originally typeof. It stopped working???
            if (local_data instanceof Array) {
                for (let j = 0; j &lt; local_data.length; j++) {
                    // console.log(item);
                    let item = local_data[j];
                    let conditions_met = true;
                    for (let i = 0; i &lt; conditions.length; i++) {
                        let condition = conditions[i];
                        let key = condition[0];
                        let op = condition[1];
                        let value = condition[2];
                        var db_value = item[key];

                        if (comp_op[op](db_value, value)) {
                            conditions_met = true &amp;&amp; conditions_met;
                        } else {
                            conditions_met = false;
                        }
                    }

                    if (conditions_met) {
                        console.log(conditions_met);
                        returned_filtered_data = true;
                        callback(item);
                    }
                }
            }

            if (conditions.length == 0) {
                callback(local_data);
            }
        });
    } catch (e) {
        console.log(e);
    }
}

/**
 * gets all the items contained within a collection
 * 
 * @param {string} accountName the user id of the signed in user
 * @param {string} collection the period delimited collection
 * @param {function} callback called with one parameter containing the array of items contained within a collection
 */
export const getSubcollectionLocalDB = async (accountName, collection, callback) => {
    try {
        getDB(async (db) => {
            if (accountName in db &amp;&amp; collection in db[accountName]) {
                callback(Object.values(db[accountName][collection]));
            } else {
                callback([]);
            }
        });
    } catch (e) {
        console.log(e);
    }
}

/**
 *  takes an array of items and puts them in a the specified collection
 * 
 * @param {string} accountName the id of the currently signed in user
 * @param {string} collection the period delimited path to the collection
 * @param {Array} dataArr contains all the items that should be added to a collection
 * @param {function} callback called when the data is written to storage
 */
export const setSubcollectionLocalDB = async (accountName, collection, dataArr, callback) => {
    try {
        getDB(async (db) => {
            if (!(accountName in db)) {
                db[accountName] = {};
            }

            if (accountName in db &amp;&amp; collection in db[accountName]) {
                db[accountName][collection] = [
                    ...db[accountName][collection],
                    ...dataArr
                ]
            } else {
                db[accountName][collection] = dataArr;
            }

            setDB(db, callback);
        });
    } catch (e) {
        console.log(e);
    }
}

/**
 * 
 * @param {Object} db the database read from local storage
 * @param {string} accountName the id of the currently signed in user
 * @param {string} collection the period delimited path to a collection
 * @param {string} oldId the original id of the document
 * @param {string} newId the updated id of the document
 */
const addDocIDMapping = (db, accountName, collection, oldId, newId) => {
    if (!('sync_mappings' in db[accountName])) {
        db[accountName]['sync_mappings'] = [];
    }

    db[accountName]['sync_mappings'] = [
        ...db[accountName]['sync_mappings'],
        {'location': collection, 'oldId': oldId, 'newId': newId},
    ];
} 

/**
 * Updates the metainfo of a particular item in the database
 * 
 * @param {string} accountName the user id of the signed in user
 * @param {string} collection the period delimited path of the collection
 * @param {boolean} isSynced whether or not a document has been synced with the remote database already
 * @param {string} oldId the original id of the document
 * @param {string} newId the new/updated id of the document
 * @param {function} callback called when finished writing to local storage
 */
export const modifyDBEntryMetainfo = async (accountName, collection, isSynced = false, oldId, newId, callback) => {
    try {
        getDB(async (db) => {
            if (accountName in db &amp;&amp; collection in db[accountName] &amp;&amp; oldId in db[accountName][collection]) {
                db[accountName][collection][newId] = db[accountName][collection][oldId];
                db[accountName][collection][newId]['meta_id'] = newId;
                delete db[accountName][collection][oldId];
                let id = newId;
                db[accountName][collection][id] = addOrUpdateMetainfo(db[accountName][collection][id], isSynced);
                addDocIDMapping(db, accountName, collection, oldId, newId);
            }

            setDB(db, () => {
                callback();
            });
        });
    } catch (e) {
        console.log(e);
    }
}

/**
 * Retuns all the unsynced documents that have not been pushed to the remote database
 * 
 * @param {string} accountName the user id of the signed in user
 * @param {function} callback called with one parameter containing an array of unsynced documents
 */
export const getUnsyncedDocuments = async (accountName, callback) => {
    try {
        getDB((db) => {
            if (accountName in db &amp;&amp; 'unsynced_documents' in db[accountName]) {
                callback(db[accountName]['unsynced_documents']);
            } else {
                callback([]);
            }
        });
    } catch (e) {
        console.log(e);
        callback([]);
    }
}

/**
 * Replaces all instances of a docid within the unsynced documents array with the one generated remotely 
 * 
 * @param {string} accountName the user id of the signed in user
 * @param {string} collection the period delimited path to the collection
 * @param {string} local_id the id of the local document 
 * @param {string} remote_id the id of the remote document that corresponds to the same local document
 * @param {function} callback called when finished writing to local storage
 */
export const replaceUnsyncedDocumentsId = async (accountName, collection, local_id, remote_id, callback) => {
    try {
        getDB((db) => {
            if (accountName in db &amp;&amp; 'unsynced_documents' in db[accountName]) {
                let u_docs = db[accountName]['unsynced_documents'];
                for (let i = 0; i &lt; u_docs.length; i++) {
                    let doc = u_docs[i];

                    if (doc['location'] == collection &amp;&amp; doc['id'] == local_id) {
                        doc['id'] = remote_id;
                    }
                }
                setDB(db, () => {
                    callback();
                });
            } else {
                callback();
            }
        });
    } catch (e) {
        console.log(e);
        callback();
    }
}

export const removeDocumentFromUnsyncedList = (accountName, location, id, callback) => {
    try {
        getDB((db) => {
            console.log("got the db");
            if (accountName in db &amp;&amp; 'unsynced_documents' in db[accountName]) {
                console.log("accountName and unsynced_documents are in the db");
                let unsynced_documents = db[accountName]['unsynced_documents'];
                db[accountName]['unsynced_documents'] = unsynced_documents.filter((doc) => doc['location'] != location &amp;&amp; doc['id'] != id);
                setDB(db, callback);
            } else {
                callback();
            }
        });
    } catch (e) {
        console.log(e);
        callback();
    }
}

export const printLocalDB = async () => {
    try {
        getDB(async (db) => {
            console.log((db));
        });
    } catch (e) {
        console.log(e);
    }
}


/**
 * Function to store local variable that keeps track of if user wants
 * to see help menu for adding card by camera
 * @param {boolean} showCameraHelpMenu - true to show, false to hide on startup
 */
export const setShowCameraHelpMenu = async (showCameraHelpMenu) => {
    try {
        const jsonValue = JSON.stringify(showCameraHelpMenu);
        await AsyncStorage.setItem('showCameraHelpMenu', jsonValue);
    } catch (e) {
        console.log(e);
    }
}

/**
 * Function to get local variable that keeps track of if user wants
 * to see help menu for adding card by camera
 * @param {function} - callback function to apply to return value
 */
export const getShowCameraHelpMenu = async (callback) => {
    try {
        const jsonValue = await AsyncStorage.getItem('showCameraHelpMenu');
        if (jsonValue == null) { // default
            callback(true);
        } else {
            callback(JSON.parse(jsonValue));
        }
    } catch (e) {
        console.log(e);
        return null;
    }
}

/**
 * Sets local list of disabled cards. If a card is already disabled, will undisable the 
 * card. If the card has not been disabled yet, will include it in list of disabled cards
 * @param {*} newDisabledCards 
 */
export const setDisabledCards = async (cardId) => {
    try {
        const jsonValue = await AsyncStorage.getItem('disabledCards');
        // default, nothing set yet
        if (jsonValue == null) { 
            let cardIdList = [];
            cardIdList.push(cardId);
            const newVal = JSON.stringify({'cards':cardIdList});
            await AsyncStorage.setItem('disabledCards', newVal);
        } else {
            let cardIdList = JSON.parse(jsonValue)['cards'];
            // undisable card
            if (cardIdList.includes(cardId)) { 
                const index = cardIdList.indexOf(cardId);
                cardIdList.splice(index, 1);
                const newVal = JSON.stringify({'cards':cardIdList});
                await AsyncStorage.setItem('disabledCards', newVal);
            // disable card
            } else { 
                cardIdList.push(cardId);
                const newVal = JSON.stringify({'cards':cardIdList});
                await AsyncStorage.setItem('disabledCards', newVal);
                console.log('finished')
            }
        }
    } catch (e) {
        console.log(e);
    }
}

/**
 * Gets the list of disabled cards
 * @param {*} callback 
 */
export const getDisabledCards = async (callback) => {
    try {
        const jsonValue = await AsyncStorage.getItem('disabledCards');
        if (jsonValue == null) { //default, nothing set yet
            callback({'cards':[]});
        } else {
            callback(JSON.parse(jsonValue));
        }
    } catch (e) {
        console.log(e);
        return null;
    }
}


/**
 * Function to store limits for each category
 * @param {Array&lt;int>} categoriesLimit - limit in dollars for each category
 */
 export const storeCategoriesLimit = async (categoriesLimit) => {
    try {
        const jsonValue = JSON.stringify(categoriesLimit);
        await AsyncStorage.setItem('categoriesLimit', jsonValue);
    } catch (e) {
        console.log(e);
    }
}

/**
 * Function to get limits for each category
 * @param {function} - callback function to apply to return value
 */
 export const getCategoriesLimit = async (callback) => {
    try {
        const jsonValue = await AsyncStorage.getItem('categoriesLimit');
        if (jsonValue == null) {
            callback(null);
        } else {
            callback(JSON.parse(jsonValue));
        }
    } catch (e) {
        console.log(e);
        return null;
    }
}

/**
 *
 * 
 * @param {Object} db the database read from the phone's storage
 * @param {string} accountName the user id associated with a logged in account
 * @param {string} collection the period delimited path to a collection
 * @param {string} id the id of a document
 * @param {string} location the period delimited path to a document
 */
function addToUnsyncedDocuments(db, type, accountName, collection, id, location) {
    if ('unsynced_documents' in db[accountName]) { // unsynced document's already exist
        db[accountName]['unsynced_documents'] = [
            ...db[accountName]['unsynced_documents'],
            { 'location': collection, 'id': id, 'type': type },
        ];
    } else { // unsynced documents don't exist yet
        db[accountName]['unsynced_documents'] = [
            { 'location': location, 'id': id, 'type': type }
        ];
    }
}
</code></pre>
        </article>
    </section>





</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Thu Jun 03 2021 12:50:08 GMT-0700 (Pacific Daylight Time) using the LOKE theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
